<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `Select` struct in crate `crossbeam_channel`."><meta name="keywords" content="rust, rustlang, rust-lang, Select"><title>crossbeam_channel::Select - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Struct Select</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.new">new</a><a href="#method.with_timeout">with_timeout</a><a href="#method.send">send</a><a href="#method.recv">recv</a><a href="#method.disconnected">disconnected</a><a href="#method.would_block">would_block</a><a href="#method.timed_out">timed_out</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a></div></div><p class='location'><a href='index.html'>crossbeam_channel</a></p><script>window.sidebarCurrent = {name: 'Select', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>crossbeam_channel</a>::<wbr><a class="struct" href=''>Select</a></span><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/crossbeam_channel/select/mod.rs.html#309-311' title='goto source code'>[src]</a></span></h1><div class="docblock type-decl"><pre class='rust struct'>pub struct Select { /* fields omitted */ }</pre></div><div class='docblock'><p>The dynamic selection interface.</p>
<p>It allows declaring an arbitrary (possibly dynamic) list of operations on channels, and waiting
until exactly one of them fires. The interface is somewhat tricky to use and care must be taken
in order to use it correctly.</p>
<p>If possible, it is highly recommended to use the <a href="macro.select_loop.html"><code>select_loop!</code></a> macro instead, which is much
easier to use. The downside of the macro is that it only allows selecting over a statically
defined set of operations.</p>
<h1 id="what-is-selection" class="section-header"><a href="#what-is-selection">What is selection?</a></h1>
<p>It is possible to declare a set of possible send and/or receive operations on channels, and
then wait until exactly one of them fires (in other words, one of them is <em>selected</em>).</p>
<p>For example, we might want to receive a message from a set of two channels and block until a
message is received from any of them. To do that, we would write:</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>;
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> (<span class="ident">tx1</span>, <span class="ident">rx1</span>) <span class="op">=</span> <span class="ident">unbounded</span>();
<span class="kw">let</span> (<span class="ident">tx2</span>, <span class="ident">rx2</span>) <span class="op">=</span> <span class="ident">unbounded</span>();

<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> <span class="ident">tx1</span>.<span class="ident">send</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">unwrap</span>());
<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> <span class="ident">tx2</span>.<span class="ident">send</span>(<span class="string">&quot;bar&quot;</span>).<span class="ident">unwrap</span>());

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">new</span>();
<span class="kw">loop</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">msg</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="ident">rx1</span>) {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;A message was received from rx1: {:?}&quot;</span>, <span class="ident">msg</span>);
        <span class="kw">break</span>;
    }
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">msg</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="ident">rx2</span>) {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;A message was received from rx2: {:?}&quot;</span>, <span class="ident">msg</span>);
        <span class="kw">break</span>;
    }
}</pre>
<p>There are two selection <em>cases</em>: a receive on <code>rx1</code> and a receive on <code>rx2</code>. The loop is
continuously probing both channels until one of the cases successfully receives a message. Then
we print the message and the loop is broken.</p>
<p>Note that <code>sel</code> holds an internal state machine that keeps track of how many cases there are,
which channels are disconnected, etc. It is smart enough to automatically register each case
into an internal conditional variable of sorts, block on it, and wake up when any of the cases
become ready.</p>
<p>You don't need to wory about blocking or about the loop burning CPU time - the selection
mechanism will automatically block and wake up the current thread as is necessary. However,
there are a few rules that must be followed when probing cases in a loop.</p>
<h1 id="selection-cases" class="section-header"><a href="#selection-cases">Selection cases</a></h1>
<p>There are five kinds of selection cases:</p>
<ol>
<li>A <em>receive</em> case, which fires when a message can be received from the channel.</li>
<li>A <em>send</em> case, which fires when the message can be sent into the channel.</li>
<li>A <em>would block</em> case, which fires when all receive and send operations in the loop would
block.</li>
<li>A <em>disconnected</em> case, which fires when all operations in the loop are working with
disconnected channels.</li>
<li>A <em>timed out</em> case, which fires when selection is blocked for longer than the specified
timeout.</li>
</ol>
<h1 id="selection-rules" class="section-header"><a href="#selection-rules">Selection rules</a></h1>
<p>Rules which must be respected in order for selection to work properly:</p>
<ol>
<li>Before each selection, a fresh <a href="struct.Select.html"><code>Select</code></a> must be created.</li>
<li>Selection cases must be repeatedly probed in a loop.</li>
<li>If a selection case fires, the loop must be broken without probing cases any further.</li>
<li>In each iteration of the loop, the same set of cases must be probed in the same order.</li>
<li>No selection case may be repeated.</li>
<li>No two cases may operate on the same end (receiving or sending) of the same channel.</li>
<li>There must be at least one <em>send</em>, or at least one <em>recv</em> case.</li>
</ol>
<p>Violating any of these rules will either result in a panic, deadlock, or livelock, possibly
even in a seemingly unrelated send or receive operations outside this particular selection
loop.</p>
<h1 id="guarantees" class="section-header"><a href="#guarantees">Guarantees</a></h1>
<ol>
<li>Exactly one case fires.</li>
<li>If none of the cases can fire at the time, one of the calls in the loop will block the
current thread.</li>
<li>If blocked, the current thread will be woken up as soon a message is pushed/popped into/from
any channel waited on by a receive/send case, or if all channels become disconnected.</li>
</ol>
<p>Finally, if more than one send or receive case can fire at the same time, a pseudorandom case
will be selected, but on a best-effort basis only. The mechanism isn't promising any strict
guarantees on fairness.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1><h2 id="receive-a-message-of-the-same-type-from-two-channels" class="section-header"><a href="#receive-a-message-of-the-same-type-from-two-channels">Receive a message of the same type from two channels</a></h2>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>;
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> (<span class="ident">tx1</span>, <span class="ident">rx1</span>) <span class="op">=</span> <span class="ident">unbounded</span>();
<span class="kw">let</span> (<span class="ident">tx2</span>, <span class="ident">rx2</span>) <span class="op">=</span> <span class="ident">unbounded</span>();

<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> <span class="ident">tx1</span>.<span class="ident">send</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">unwrap</span>());
<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> <span class="ident">tx2</span>.<span class="ident">send</span>(<span class="string">&quot;bar&quot;</span>).<span class="ident">unwrap</span>());

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">new</span>();
<span class="kw">let</span> <span class="ident">msg</span> <span class="op">=</span> <span class="kw">loop</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">msg</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="ident">rx1</span>) {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Received from rx1.&quot;</span>);
        <span class="kw">break</span> <span class="ident">msg</span>;
    }
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">msg</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="ident">rx2</span>) {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Received from rx2.&quot;</span>);
        <span class="kw">break</span> <span class="ident">msg</span>;
    }
};

<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Message: {:?}&quot;</span>, <span class="ident">msg</span>);</pre>
<h2 id="send-a-non-copy-message-regaining-ownership-on-each-failure" class="section-header"><a href="#send-a-non-copy-message-regaining-ownership-on-each-failure">Send a non-<code>Copy</code> message, regaining ownership on each failure</a></h2>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">unbounded</span>();

<span class="comment">// The message we&#39;re going to send.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">msg</span> <span class="op">=</span> <span class="string">&quot;Hello!&quot;</span>.<span class="ident">to_string</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">new</span>();
<span class="kw">loop</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Err</span>(<span class="ident">err</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">send</span>(<span class="kw-2">&amp;</span><span class="ident">tx</span>, <span class="ident">msg</span>) {
        <span class="comment">// This selection case didn&#39;t fire yet.</span>
        <span class="comment">// Regain ownership of the message, which is contained in `err`.</span>
        <span class="ident">msg</span> <span class="op">=</span> <span class="ident">err</span>.<span class="number">0</span>;
    } <span class="kw">else</span> {
        <span class="comment">// The message was successfully sent.</span>
        <span class="kw">break</span>;
    }
}</pre>
<h2 id="stop-if-all-channels-are-disconnected" class="section-header"><a href="#stop-if-all-channels-are-disconnected">Stop if all channels are disconnected</a></h2>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">unbounded</span>();

<span class="comment">// Disconnect the channel.</span>
<span class="ident">drop</span>(<span class="ident">rx</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">new</span>();
<span class="kw">loop</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="kw">_</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">send</span>(<span class="kw-2">&amp;</span><span class="ident">tx</span>, <span class="string">&quot;message&quot;</span>) {
        <span class="comment">// Won&#39;t happen. The channel is disconnected.</span>
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Sent the message.&quot;</span>);
        <span class="macro">panic</span><span class="macro">!</span>();
        <span class="kw">break</span>;
    }
    <span class="kw">if</span> <span class="ident">sel</span>.<span class="ident">disconnected</span>() {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;All channels are disconnected! Stopping selection.&quot;</span>);
        <span class="kw">break</span>;
    }
}</pre>
<h2 id="stop-if-all-operations-would-block" class="section-header"><a href="#stop-if-all-operations-would-block">Stop if all operations would block</a></h2>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">unbounded</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">new</span>();
<span class="kw">loop</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">msg</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="ident">rx</span>) {
        <span class="comment">// Won&#39;t happen. The channel is empty.</span>
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Received message: {:?}&quot;</span>, <span class="ident">msg</span>);
        <span class="macro">panic</span><span class="macro">!</span>();
        <span class="kw">break</span>;
    }
    <span class="kw">if</span> <span class="ident">sel</span>.<span class="ident">would_block</span>() {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;All operations would block. Stopping selection.&quot;</span>);
        <span class="kw">break</span>;
    }
}</pre>
<h2 id="selection-with-a-timeout" class="section-header"><a href="#selection-with-a-timeout">Selection with a timeout</a></h2>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::<span class="ident">Duration</span>;
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">unbounded</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">with_timeout</span>(<span class="ident">Duration</span>::<span class="ident">from_secs</span>(<span class="number">1</span>));
<span class="kw">loop</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">msg</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="ident">rx</span>) {
        <span class="comment">// Won&#39;t happen. The channel is empty.</span>
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Received message: {:?}&quot;</span>, <span class="ident">msg</span>);
        <span class="macro">panic</span><span class="macro">!</span>();
        <span class="kw">break</span>;
    }
    <span class="kw">if</span> <span class="ident">sel</span>.<span class="ident">timed_out</span>() {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Timed out after 1 second.&quot;</span>);
        <span class="kw">break</span>;
    }
}</pre>
<h2 id="one-send-and-one-receive-operation-on-the-same-channel" class="section-header"><a href="#one-send-and-one-receive-operation-on-the-same-channel">One send and one receive operation on the same channel</a></h2>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">bounded</span>, <span class="ident">Sender</span>, <span class="ident">Receiver</span>, <span class="ident">Select</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>;

<span class="comment">// Either send my name into the channel or receive someone else&#39;s, whatever happens first.</span>
<span class="kw">fn</span> <span class="ident">seek</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span>, <span class="ident">tx</span>: <span class="ident">Sender</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span><span class="op">&gt;</span>, <span class="ident">rx</span>: <span class="ident">Receiver</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span><span class="op">&gt;</span>) {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">new</span>();
    <span class="kw">loop</span> {
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">peer</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="ident">rx</span>) {
            <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} received a message from {}.&quot;</span>, <span class="ident">name</span>, <span class="ident">peer</span>);
            <span class="kw">break</span>;
        }
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(()) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">send</span>(<span class="kw-2">&amp;</span><span class="ident">tx</span>, <span class="ident">name</span>) {
            <span class="comment">// Wait for someone to receive my message.</span>
            <span class="kw">break</span>;
        }
    }
}

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">bounded</span>(<span class="number">1</span>); <span class="comment">// Make room for one unmatched send.</span>

<span class="comment">// Pair up five people by exchanging messages over the channel.</span>
<span class="comment">// Since there is an odd number of them, one person won&#39;t have its match.</span>
[<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Cody&quot;</span>, <span class="string">&quot;Dave&quot;</span>, <span class="string">&quot;Eva&quot;</span>].<span class="ident">iter</span>()
    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">name</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">tx</span> <span class="op">=</span> <span class="ident">tx</span>.<span class="ident">clone</span>();
        <span class="kw">let</span> <span class="ident">rx</span> <span class="op">=</span> <span class="ident">rx</span>.<span class="ident">clone</span>();
        <span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> <span class="ident">seek</span>(<span class="ident">name</span>, <span class="ident">tx</span>, <span class="ident">rx</span>))
    })
    .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;&gt;</span>()
    .<span class="ident">into_iter</span>()
    .<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="ident">t</span>.<span class="ident">join</span>().<span class="ident">unwrap</span>());

<span class="comment">// Let&#39;s send a message to the remaining person who doesn&#39;t have a match.</span>
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">name</span>) <span class="op">=</span> <span class="ident">rx</span>.<span class="ident">try_recv</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;No one received {}’s message.&quot;</span>, <span class="ident">name</span>);
}</pre>
<h2 id="receive-a-message-from-a-dynamic-list-of-receivers" class="section-header"><a href="#receive-a-message-from-a-dynamic-list-of-receivers">Receive a message from a dynamic list of receivers</a></h2>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>;
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chans</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[];
<span class="kw">for</span> <span class="kw">_</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">10</span> {
    <span class="ident">chans</span>.<span class="ident">push</span>(<span class="ident">unbounded</span>());
}

<span class="kw">let</span> <span class="ident">tx</span> <span class="op">=</span> <span class="ident">chans</span>[<span class="number">7</span>].<span class="number">0</span>.<span class="ident">clone</span>();

<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">new</span>();

    <span class="kw">let</span> <span class="ident">msg</span> <span class="op">=</span> <span class="lifetime">&#39;select</span>: <span class="kw">loop</span> {
        <span class="comment">// In each iteration of the selection loop we probe cases in the same order.</span>
        <span class="kw">for</span> <span class="kw-2">&amp;</span>(<span class="kw">_</span>, <span class="kw-2">ref</span> <span class="ident">rx</span>) <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">chans</span> {
            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">msg</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">recv</span>(<span class="ident">rx</span>) {
                <span class="comment">// Finally, this case fired.</span>
                <span class="comment">// Break the outer loop with the received message as the result.</span>
                <span class="kw">break</span> <span class="lifetime">&#39;select</span> <span class="ident">msg</span>;
            }
        }
    };

    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Received message: {:?}&quot;</span>, <span class="ident">msg</span>);
});

<span class="ident">tx</span>.<span class="ident">send</span>(<span class="string">&quot;Hello!&quot;</span>).<span class="ident">unwrap</span>();</pre>
</div>
                    <h2 id='methods' class='small-section-header'>
                      Methods<a href='#methods' class='anchor'></a>
                    </h2>
                <h3 id='impl' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="struct" href="../crossbeam_channel/struct.Select.html" title="struct crossbeam_channel::Select">Select</a></code><a href='#impl' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/crossbeam_channel/select/mod.rs.html#313-485' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.new' class="method"><span id='new.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.new' class='fnname'>new</a>() -&gt; <a class="struct" href="../crossbeam_channel/struct.Select.html" title="struct crossbeam_channel::Select">Select</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/crossbeam_channel/select/mod.rs.html#324-328' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Constructs a new state machine for selection.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">new</span>();</pre>
</div><h4 id='method.with_timeout' class="method"><span id='with_timeout.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.with_timeout' class='fnname'>with_timeout</a>(timeout: <a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>) -&gt; <a class="struct" href="../crossbeam_channel/struct.Select.html" title="struct crossbeam_channel::Select">Select</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/crossbeam_channel/select/mod.rs.html#341-345' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Constructs a new state machine for selection with a specific <code>timeout</code>.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::<span class="ident">Duration</span>;
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">with_timeout</span>(<span class="ident">Duration</span>::<span class="ident">from_secs</span>(<span class="number">5</span>));</pre>
</div><h4 id='method.send' class="method"><span id='send.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.send' class='fnname'>send</a>&lt;T&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;tx: &amp;<a class="struct" href="../crossbeam_channel/struct.Sender.html" title="struct crossbeam_channel::Sender">Sender</a>&lt;T&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;msg: T<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="../crossbeam_channel/struct.SelectSendError.html" title="struct crossbeam_channel::SelectSendError">SelectSendError</a>&lt;T&gt;&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/crossbeam_channel/select/mod.rs.html#366-368' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Probes a <em>send</em> case.</p>
<p>The operation is attempting to send <code>msg</code> through <code>tx</code>.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">unbounded</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">new</span>();
<span class="kw">loop</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="kw">_</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">send</span>(<span class="kw-2">&amp;</span><span class="ident">tx</span>, <span class="string">&quot;foo&quot;</span>) {
        <span class="comment">// The message was successfully sent.</span>
        <span class="kw">break</span>;
    }
}</pre>
</div><h4 id='method.recv' class="method"><span id='recv.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.recv' class='fnname'>recv</a>&lt;T&gt;(&amp;mut self, rx: &amp;<a class="struct" href="../crossbeam_channel/struct.Receiver.html" title="struct crossbeam_channel::Receiver">Receiver</a>&lt;T&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, <a class="struct" href="../crossbeam_channel/struct.SelectRecvError.html" title="struct crossbeam_channel::SelectRecvError">SelectRecvError</a>&gt;</code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/crossbeam_channel/select/mod.rs.html#391-393' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Probes a <em>receive</em> case.</p>
<p>The operation is attempting to receive a message through <code>rx</code>.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">unbounded</span>();
<span class="ident">tx</span>.<span class="ident">send</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">new</span>();
<span class="kw">loop</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">msg</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="ident">rx</span>) {
        <span class="comment">// The message was successfully received.</span>
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">msg</span>, <span class="string">&quot;foo&quot;</span>);
        <span class="kw">break</span>;
    }
}</pre>
</div><h4 id='method.disconnected' class="method"><span id='disconnected.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.disconnected' class='fnname'>disconnected</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/crossbeam_channel/select/mod.rs.html#423-425' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Probes a <em>disconnected</em> case.</p>
<p>This case fires when all operations in the loop are working with disconnected channels.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">unbounded</span>();

<span class="comment">// Disconnect the channel.</span>
<span class="ident">drop</span>(<span class="ident">rx</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">new</span>();
<span class="kw">loop</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="kw">_</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">send</span>(<span class="kw-2">&amp;</span><span class="ident">tx</span>, <span class="string">&quot;foo&quot;</span>) {
        <span class="comment">// The message was successfully sent.</span>
        <span class="macro">panic</span><span class="macro">!</span>();
        <span class="kw">break</span>;
    }
    <span class="kw">if</span> <span class="ident">sel</span>.<span class="ident">disconnected</span>() {
        <span class="comment">// All channels are disconnected.</span>
        <span class="kw">break</span>;
    }
}</pre>
</div><h4 id='method.would_block' class="method"><span id='would_block.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.would_block' class='fnname'>would_block</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/crossbeam_channel/select/mod.rs.html#452-454' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Probes a <em>would block</em> case.</p>
<p>This case fires when all operations in the loop would block.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">unbounded</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">new</span>();
<span class="kw">loop</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">msg</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="ident">rx</span>) {
        <span class="comment">// The message was successfully received.</span>
        <span class="macro">panic</span><span class="macro">!</span>();
        <span class="kw">break</span>;
    }
    <span class="kw">if</span> <span class="ident">sel</span>.<span class="ident">would_block</span>() {
        <span class="comment">// All operation would block.</span>
        <span class="kw">break</span>;
    }
}</pre>
</div><h4 id='method.timed_out' class="method"><span id='timed_out.v' class='invisible'><table class='table-display'><tbody><tr><td><code>pub fn <a href='#method.timed_out' class='fnname'>timed_out</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/crossbeam_channel/select/mod.rs.html#482-484' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Probes a <em>timed out</em> case.</p>
<p>This case fires when selection is blocked for longer than the specified timeout.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::<span class="ident">Duration</span>;
<span class="kw">use</span> <span class="ident">crossbeam_channel</span>::{<span class="ident">unbounded</span>, <span class="ident">Select</span>};

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">unbounded</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">Select</span>::<span class="ident">with_timeout</span>(<span class="ident">Duration</span>::<span class="ident">from_secs</span>(<span class="number">1</span>));
<span class="kw">loop</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">msg</span>) <span class="op">=</span> <span class="ident">sel</span>.<span class="ident">recv</span>(<span class="kw-2">&amp;</span><span class="ident">rx</span>) {
        <span class="comment">// The message was successfully received.</span>
        <span class="macro">panic</span><span class="macro">!</span>();
        <span class="kw">break</span>;
    }
    <span class="kw">if</span> <span class="ident">sel</span>.<span class="ident">timed_out</span>() {
        <span class="comment">// Selection timed out.</span>
        <span class="kw">break</span>;
    }
}</pre>
</div></div>
                <h2 id='implementations' class='small-section-header'>
                  Trait Implementations<a href='#implementations' class='anchor'></a>
                </h2>
                <div id='implementations-list'><h3 id='impl-Debug' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../crossbeam_channel/struct.Select.html" title="struct crossbeam_channel::Select">Select</a></code><a href='#impl-Debug' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/crossbeam_channel/select/mod.rs.html#487-491' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.fmt' class="method"><span id='fmt.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/crossbeam_channel/select/mod.rs.html#488-490' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-Default' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="../crossbeam_channel/struct.Select.html" title="struct crossbeam_channel::Select">Select</a></code><a href='#impl-Default' class='anchor'></a></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/crossbeam_channel/select/mod.rs.html#493-497' title='goto source code'>[src]</a></span></td></tr></tbody></table></h3><div class='impl-items'><h4 id='method.default' class="method"><span id='default.v' class='invisible'><table class='table-display'><tbody><tr><td><code>fn <a href='https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default' class='fnname'>default</a>() -&gt; <a class="struct" href="../crossbeam_channel/struct.Select.html" title="struct crossbeam_channel::Select">Select</a></code></span></td><td><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/crossbeam_channel/select/mod.rs.html#494-496' title='goto source code'>[src]</a></td></tr></tbody></table></span></h4><div class='docblock'><p>Returns the &quot;default value&quot; for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div></div>
                <h2 id='synthetic-implementations' class='small-section-header'>
                  Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a>
                </h2>
                <div id='synthetic-implementations-list'>
            <h3 id='impl-Send' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../crossbeam_channel/struct.Select.html" title="struct crossbeam_channel::Select">Select</a></code><a href='#impl-Send' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><span class='in-band'><table class='table-display'><tbody><tr><td><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../crossbeam_channel/struct.Select.html" title="struct crossbeam_channel::Select">Select</a></code><a href='#impl-Sync' class='anchor'></a></span></td><td><span class='out-of-band'></span></td></tr></tbody></table></h3><div class='impl-items'></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "crossbeam_channel";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>