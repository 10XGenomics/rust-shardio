<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `select_loop` macro in crate `crossbeam_channel`."><meta name="keywords" content="rust, rustlang, rust-lang, select_loop"><title>crossbeam_channel::select_loop - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script></head><body class="rustdoc macro"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><div class="sidebar-elems"><p class='location'><a href='index.html'>crossbeam_channel</a></p><script>window.sidebarCurrent = {name: 'select_loop', ty: 'macro', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='in-band'>Macro <a href='index.html'>crossbeam_channel</a>::<wbr><a class="macro" href=''>select_loop</a></span><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/crossbeam_channel/select/select_loop.rs.html#319-463' title='goto source code'>[src]</a></span></h1><div class="docblock type-decl"><pre class="rust macro">
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">select_loop</span> {
    {$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">method</span>:<span class="ident">ident</span>($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">args</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>) $(<span class="kw">if</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">guard</span>:<span class="ident">expr</span>)<span class="op">*</span> <span class="op">=&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">expr</span>$(,)<span class="kw-2">*</span>)<span class="kw-2">*</span>} <span class="op">=&gt;</span> { ... };
    {@<span class="kw">impl</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">state</span>:<span class="ident">ident</span>) <span class="ident">send</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">tx</span>:<span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">val</span>:<span class="ident">ident</span>) <span class="op">=&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">expr</span>} <span class="op">=&gt;</span> { ... };
    {@<span class="kw">impl</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">state</span>:<span class="ident">ident</span>) <span class="ident">send</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">tx</span>:<span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">val</span>:<span class="ident">ident</span>) <span class="op">=&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">expr</span>} <span class="op">=&gt;</span> { ... };
    {@<span class="kw">impl</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">state</span>:<span class="ident">ident</span>) <span class="ident">send</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">tx</span>:<span class="ident">expr</span>, <span class="kw-2">mut</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">val</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">expr</span>} <span class="op">=&gt;</span> { ... };
    {@<span class="kw">impl</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">state</span>:<span class="ident">ident</span>) <span class="ident">send</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">tx</span>:<span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">val</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">expr</span>} <span class="op">=&gt;</span> { ... };
    {@<span class="kw">impl</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">state</span>:<span class="ident">ident</span>) <span class="ident">recv</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">rx</span>:<span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">val</span>:<span class="ident">pat</span>) <span class="op">=&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">expr</span>} <span class="op">=&gt;</span> { ... };
    {@<span class="kw">impl</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">state</span>:<span class="ident">ident</span>) <span class="ident">disconnected</span>() <span class="op">=&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">expr</span>} <span class="op">=&gt;</span> { ... };
    {@<span class="kw">impl</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">state</span>:<span class="ident">ident</span>) <span class="ident">would_block</span>() <span class="op">=&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">expr</span>} <span class="op">=&gt;</span> { ... };
    {@<span class="kw">impl</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">state</span>:<span class="ident">ident</span>) <span class="ident">timed_out</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">_timeout</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">expr</span>} <span class="op">=&gt;</span> { ... };
    {@<span class="ident">prelude</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">state</span>:<span class="ident">ident</span>) <span class="ident">send</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">tx</span>:<span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">val</span>:<span class="ident">ident</span>) $(<span class="kw">if</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">_guard</span>:<span class="ident">expr</span>)<span class="kw-2">*</span>} <span class="op">=&gt;</span> { ... };
    {@<span class="ident">prelude</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">state</span>:<span class="ident">ident</span>) <span class="ident">timed_out</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">timeout</span>:<span class="ident">expr</span>) $(<span class="kw">if</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">guard</span>:<span class="ident">expr</span>)<span class="kw-2">*</span>} <span class="op">=&gt;</span> { ... };
    {@<span class="ident">prelude</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">state</span>:<span class="ident">ident</span>) $(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">tail</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>} <span class="op">=&gt;</span> { ... };
    {@<span class="ident">check_guard</span>() [$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">_ctx</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>]} <span class="op">=&gt;</span> { ... };
    {@<span class="ident">check_guard</span>(<span class="kw">if</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">_guard</span>:<span class="ident">expr</span>) [$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">_ctx</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>]} <span class="op">=&gt;</span> { ... };
    {@<span class="ident">check_guard</span>($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">_tt</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>) [$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">ctx</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>]} <span class="op">=&gt;</span> { ... };
}</pre>
</div><div class='docblock'><p>The static selection macro.</p>
<p>It allows declaring an arbitrary static list of operations on channels, and waiting until
exactly one of them fires. If you need to select over a dynamic list of operations, use
<a href="struct.Select.html"><code>Select</code></a> instead. This macro is just a restricted and more user-friendly wrapper around it.</p>
<h1 id="what-is-selection" class="section-header"><a href="#what-is-selection">What is selection?</a></h1>
<p>It is possible to declare a set of possible send and/or receive operations on channels, and
then wait until exactly one of them fires (in other words, one of them is <em>selected</em>). Once the
selected operation fires, the loop is broken.</p>
<p>For example, we might want to receive a message from a set of two channels and block until a
message is received from any of them. To do that, we would write:</p>

<pre class="rust rust-example-rendered">

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>;

<span class="kw">let</span> (<span class="ident">tx1</span>, <span class="ident">rx1</span>) <span class="op">=</span> <span class="ident">channel</span>::<span class="ident">unbounded</span>();
<span class="kw">let</span> (<span class="ident">tx2</span>, <span class="ident">rx2</span>) <span class="op">=</span> <span class="ident">channel</span>::<span class="ident">unbounded</span>();

<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> <span class="ident">tx1</span>.<span class="ident">send</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">unwrap</span>());
<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> <span class="ident">tx2</span>.<span class="ident">send</span>(<span class="string">&quot;bar&quot;</span>).<span class="ident">unwrap</span>());

<span class="macro">select_loop</span><span class="macro">!</span> {
    <span class="ident">recv</span>(<span class="ident">rx1</span>, <span class="ident">msg</span>) <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;A message was received from rx1: {:?}&quot;</span>, <span class="ident">msg</span>),
    <span class="ident">recv</span>(<span class="ident">rx2</span>, <span class="ident">msg</span>) <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;A message was received from rx2: {:?}&quot;</span>, <span class="ident">msg</span>),
}
</pre>
<p>There are two selection <em>cases</em>: a receive on <code>rx1</code> and a receive on <code>rx2</code>. The macro is in
fact loop, which is continuously probing both channels until one of the cases successfully
receives a message. Then we print the message and the loop is broken.</p>
<p>The loop will automatically block the current thread if none of the operations can proceed and
wake up as soon as any one of them becomes ready. However, there are a few rules that must be
followed when declaring a set of cases in a loop.</p>
<h1 id="selection-cases" class="section-header"><a href="#selection-cases">Selection cases</a></h1>
<p>There are five kinds of selection cases:</p>
<ol>
<li>A <em>receive</em> case, which fires when a message can be received from the channel.</li>
<li>A <em>send</em> case, which fires when the message can be sent into the channel.</li>
<li>A <em>would block</em> case, which fires when all receive and send operations in the loop would
block.</li>
<li>A <em>disconnected</em> case, which fires when all operations in the loop are working with
disconnected channels.</li>
<li>A <em>timed out</em> case, which fires when selection is blocked for longer than the specified
timeout.</li>
</ol>
<p>Additionally, every case may optionally be guarded by a condition, so that the case is enabled
only if the condition is true. Note that such conditions must not change within the
<code>select_loop!</code>.</p>
<h1 id="selection-rules" class="section-header"><a href="#selection-rules">Selection rules</a></h1>
<p>Rules which must be respected in order for selection to work properly:</p>
<ol>
<li>No selection case may be repeated.</li>
<li>No two cases may operate on the same end (receiving or sending) of the same channel.</li>
<li>There must be at least one <em>send</em> or at least one <em>recv</em> case.</li>
<li>If case conditions are used, they must not change within the <code>select_loop!</code>.</li>
</ol>
<p>Violating any of these rules will either result in a panic, deadlock, or livelock, possibly
even in a seemingly unrelated send or receive operations outside this particular selection
loop.</p>
<h1 id="guarantees" class="section-header"><a href="#guarantees">Guarantees</a></h1>
<ol>
<li>Exactly one case fires.</li>
<li>If none of the cases can fire at the time, the current thread will be blocked.</li>
<li>If blocked, the current thread will be woken up as soon a message is pushed/popped into/from
any channel waited on by a receive/send case, or if all channels become disconnected.</li>
</ol>
<p>Finally, if more than one send or receive case can fire at the same time, a pseudorandom case
will be selected, but on a best-effort basis only. The mechanism isn't promising any strict
guarantees on fairness.</p>
<h1 id="syntax" class="section-header"><a href="#syntax">Syntax</a></h1>
<p>The macro has similar syntax to <code>match</code> expression. It takes a list of cases, where each case
is of the form <code>operation(arguments) =&gt; expression</code>. The individual cases are optionally
separated by commas. Just like <code>match</code>, the whole macro invocation is an expression, which in
the end evaluates to a single value.</p>
<p>Every case may also optionally have a guard expression at the end, in the form of
<code>operation(arguments) if guard_expression =&gt; expression</code>. The guarded case will participate in
selection only if <code>guard_expression</code> evaluates to <code>true</code>.</p>
<p>The following code illustrates the various ways in which cases can be declared:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="macro">select_loop</span><span class="macro">!</span> {
    <span class="comment">// Send `msg` into `tx1`.</span>
    <span class="comment">//</span>
    <span class="comment">// Behind the scenes, this form will actually rebind the variable in mutable form by</span>
    <span class="comment">// inserting the following line before the loop: `let mut msg = msg;`</span>
    <span class="ident">send</span>(<span class="ident">tx1</span>, <span class="ident">msg</span>) <span class="op">=&gt;</span> { ... }

    <span class="comment">// Send the result of an expression as a message into `tx2`.</span>
    <span class="comment">//</span>
    <span class="comment">// Note that this form will evaluate the expression in each iteration of the loop. If the</span>
    <span class="comment">// evaluation is expensive, you should probably do it once before the loop and bind to a</span>
    <span class="comment">// variable, then send that variable as the message.</span>
    <span class="ident">send</span>(<span class="ident">tx2</span>, <span class="ident">x</span> <span class="op">*</span> <span class="number">10</span> <span class="op">-</span> <span class="ident">y</span>) <span class="op">=&gt;</span> { ... }

    <span class="comment">// Send `msg` into `tx3`, but regain ownership on each failure.</span>
    <span class="comment">//</span>
    <span class="comment">// If sending the message fails in an interation of the loop, then ownership of the message</span>
    <span class="comment">// will be automatically regained from the error and bound back to the original variable.</span>
    <span class="comment">//</span>
    <span class="comment">// You should use this form if `msg` is not `Copy`.</span>
    <span class="ident">send</span>(<span class="ident">tx3</span>, <span class="kw-2">mut</span> <span class="ident">msg</span>) <span class="op">=&gt;</span> { ... }

    <span class="comment">// Send `msg` into `tx4` but only if `enabled_tx4` is `true`.</span>
    <span class="ident">send</span>(<span class="ident">tx4</span>, <span class="ident">msg</span>) <span class="kw">if</span> <span class="ident">enabled_tx4</span> <span class="op">=&gt;</span> { ... }

    <span class="comment">// Receive `msg` from `rx1`.</span>
    <span class="ident">recv</span>(<span class="ident">rx1</span>, <span class="ident">msg</span>) <span class="op">=&gt;</span> { ... }

    <span class="comment">// Receive `msg` from `rx2`, and make the variable mutable.</span>
    <span class="ident">recv</span>(<span class="ident">rx2</span>, <span class="kw-2">mut</span> <span class="ident">msg</span>) <span class="op">=&gt;</span> { ... }

    <span class="comment">// Receive a message from `rx3`, but don&#39;t bind it to a variable.</span>
    <span class="ident">recv</span>(<span class="ident">rx3</span>, <span class="kw">_</span>) <span class="op">=&gt;</span> { ... }

    <span class="comment">// Receive `msg` from the optional receiver, if it exists (`Option&lt;Receiver&lt;_&gt;&gt;`).</span>
    <span class="ident">recv</span>(<span class="ident">opt_rx4</span>.<span class="ident">as_ref</span>().<span class="ident">unwrap</span>(), <span class="ident">msg</span>) <span class="kw">if</span> <span class="ident">opt_rx4</span>.<span class="ident">is_some</span>() <span class="op">=&gt;</span> { ... }

    <span class="comment">// This case fires if all declared send/receive operations are on disconnected channels.</span>
    <span class="ident">disconnected</span>() <span class="op">=&gt;</span> { ... }

    <span class="comment">// This case fires if all declared send/receive operations would block.</span>
    <span class="ident">would_block</span>() <span class="op">=&gt;</span> { ... }

    <span class="comment">// This case fires if selection waits for longer than `timeout`.</span>
    <span class="comment">//</span>
    <span class="comment">// The specified `timeout` must be of type `std::time::Duration`.</span>
    <span class="ident">timed_out</span>(<span class="ident">timeout</span>) <span class="op">=&gt;</span> { ... }
}</pre>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1><h2 id="receive-a-message-of-the-same-type-from-two-channels" class="section-header"><a href="#receive-a-message-of-the-same-type-from-two-channels">Receive a message of the same type from two channels</a></h2>
<pre class="rust rust-example-rendered">

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>;

<span class="kw">let</span> (<span class="ident">tx1</span>, <span class="ident">rx1</span>) <span class="op">=</span> <span class="ident">channel</span>::<span class="ident">unbounded</span>();
<span class="kw">let</span> (<span class="ident">tx2</span>, <span class="ident">rx2</span>) <span class="op">=</span> <span class="ident">channel</span>::<span class="ident">unbounded</span>();

<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> <span class="ident">tx1</span>.<span class="ident">send</span>(<span class="string">&quot;foo&quot;</span>).<span class="ident">unwrap</span>());
<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> <span class="ident">tx2</span>.<span class="ident">send</span>(<span class="string">&quot;bar&quot;</span>).<span class="ident">unwrap</span>());

<span class="kw">let</span> <span class="ident">msg</span> <span class="op">=</span> <span class="macro">select_loop</span><span class="macro">!</span> {
    <span class="ident">recv</span>(<span class="ident">rx1</span>, <span class="ident">msg</span>) <span class="op">=&gt;</span> {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Received from rx1.&quot;</span>);
        <span class="ident">msg</span>
    }
    <span class="ident">recv</span>(<span class="ident">rx2</span>, <span class="ident">msg</span>) <span class="op">=&gt;</span> {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Received from rx2.&quot;</span>);
        <span class="ident">msg</span>
    }
};

<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Message: {:?}&quot;</span>, <span class="ident">msg</span>);
</pre>
<h2 id="send-a-non-copy-message-regaining-ownership-on-each-failure" class="section-header"><a href="#send-a-non-copy-message-regaining-ownership-on-each-failure">Send a non-<code>Copy</code> message, regaining ownership on each failure</a></h2>
<pre class="rust rust-example-rendered">

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">channel</span>::<span class="ident">unbounded</span>();

<span class="comment">// The message we&#39;re going to send.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">msg</span> <span class="op">=</span> <span class="string">&quot;Hello!&quot;</span>.<span class="ident">to_string</span>();

<span class="macro">select_loop</span><span class="macro">!</span> {
    <span class="comment">// The variable is marked with `mut`, which indicates that ownership must be reacquired if</span>
    <span class="comment">// sending the variable fails.</span>
    <span class="ident">send</span>(<span class="ident">tx</span>, <span class="kw-2">mut</span> <span class="ident">msg</span>) <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;The message was sent!&quot;</span>),

    <span class="ident">recv</span>(<span class="ident">rx</span>, <span class="ident">msg</span>) <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;A message was received: {}&quot;</span>, <span class="ident">msg</span>),
}
</pre>
<h2 id="stop-if-all-channels-are-disconnected" class="section-header"><a href="#stop-if-all-channels-are-disconnected">Stop if all channels are disconnected</a></h2>
<pre class="rust rust-example-rendered">

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">channel</span>::<span class="ident">unbounded</span>();

<span class="comment">// Disconnect the channel.</span>
<span class="ident">drop</span>(<span class="ident">rx</span>);

<span class="macro">select_loop</span><span class="macro">!</span> {
    <span class="comment">// Won&#39;t happen. The channel is disconnected.</span>
    <span class="ident">send</span>(<span class="ident">tx</span>, <span class="string">&quot;message&quot;</span>) <span class="op">=&gt;</span> {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Sent the message.&quot;</span>);
        <span class="macro">panic</span><span class="macro">!</span>();
    }

    <span class="ident">disconnected</span>() <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;All channels are disconnected! Stopping selection.&quot;</span>),
}
</pre>
<h2 id="stop-if-all-operations-would-block" class="section-header"><a href="#stop-if-all-operations-would-block">Stop if all operations would block</a></h2>
<pre class="rust rust-example-rendered">

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">channel</span>::<span class="ident">unbounded</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>();

<span class="macro">select_loop</span><span class="macro">!</span> {
    <span class="comment">// Won&#39;t happen. The channel is empty.</span>
    <span class="ident">recv</span>(<span class="ident">rx</span>, <span class="ident">msg</span>) <span class="op">=&gt;</span> {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Received message: {:?}&quot;</span>, <span class="ident">msg</span>);
        <span class="macro">panic</span><span class="macro">!</span>();
    }

    <span class="ident">would_block</span>() <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;All operations would block. Stopping selection.&quot;</span>),
}
</pre>
<h2 id="selection-with-a-timeout" class="section-header"><a href="#selection-with-a-timeout">Selection with a timeout</a></h2>
<pre class="rust rust-example-rendered">

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::<span class="ident">Duration</span>;

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">channel</span>::<span class="ident">unbounded</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>();

<span class="macro">select_loop</span><span class="macro">!</span> {
    <span class="comment">// Won&#39;t happen. The channel is empty.</span>
    <span class="ident">recv</span>(<span class="ident">rx</span>, <span class="ident">msg</span>) <span class="op">=&gt;</span> {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Received message: {:?}&quot;</span>, <span class="ident">msg</span>);
        <span class="macro">panic</span><span class="macro">!</span>();
    }

    <span class="ident">timed_out</span>(<span class="ident">Duration</span>::<span class="ident">from_secs</span>(<span class="number">1</span>)) <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Timed out after 1 second.&quot;</span>),
}
</pre>
<h2 id="one-send-and-one-receive-operation-on-the-same-channel" class="section-header"><a href="#one-send-and-one-receive-operation-on-the-same-channel">One send and one receive operation on the same channel</a></h2>
<pre class="rust rust-example-rendered">

<span class="kw">use</span> <span class="ident">channel</span>::{<span class="ident">Sender</span>, <span class="ident">Receiver</span>, <span class="ident">Select</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>;

<span class="comment">// Either send my name into the channel or receive someone else&#39;s, whatever happens first.</span>
<span class="kw">fn</span> <span class="ident">seek</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span>, <span class="ident">tx</span>: <span class="ident">Sender</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span><span class="op">&gt;</span>, <span class="ident">rx</span>: <span class="ident">Receiver</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span><span class="op">&gt;</span>) {
    <span class="macro">select_loop</span><span class="macro">!</span> {
        <span class="ident">recv</span>(<span class="ident">rx</span>, <span class="ident">peer</span>) <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} received a message from {}.&quot;</span>, <span class="ident">name</span>, <span class="ident">peer</span>),
        <span class="ident">send</span>(<span class="ident">tx</span>, <span class="ident">name</span>) <span class="op">=&gt;</span> {}
    }
}

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">channel</span>::<span class="ident">bounded</span>(<span class="number">1</span>); <span class="comment">// Make room for one unmatched send.</span>

<span class="comment">// Pair up five people by exchanging messages over the channel.</span>
<span class="comment">// Since there is an odd number of them, one person won&#39;t have its match.</span>
[<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Cody&quot;</span>, <span class="string">&quot;Dave&quot;</span>, <span class="string">&quot;Eva&quot;</span>].<span class="ident">iter</span>()
    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">name</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">tx</span> <span class="op">=</span> <span class="ident">tx</span>.<span class="ident">clone</span>();
        <span class="kw">let</span> <span class="ident">rx</span> <span class="op">=</span> <span class="ident">rx</span>.<span class="ident">clone</span>();
        <span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">||</span> <span class="ident">seek</span>(<span class="ident">name</span>, <span class="ident">tx</span>, <span class="ident">rx</span>))
    })
    .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;&gt;</span>()
    .<span class="ident">into_iter</span>()
    .<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="ident">t</span>.<span class="ident">join</span>().<span class="ident">unwrap</span>());

<span class="comment">// Let&#39;s send a message to the remaining person who doesn&#39;t have a match.</span>
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">name</span>) <span class="op">=</span> <span class="ident">rx</span>.<span class="ident">try_recv</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;No one received {}’s message.&quot;</span>, <span class="ident">name</span>);
}
</pre>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "crossbeam_channel";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>